DCSP return numpy . identity ( 4 )
DCSP t = Twitter ( auth = authen ( ) ) DCNL DCSP try : DCNL DCSP DCSP if ( not g [ 'stuff' ] . isdigit ( ) ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP tid = c [ 'tweet_dict' ] [ int ( g [ 'stuff' ] ) ] DCNL DCSP DCSP tweet = t . statuses . show ( id = tid ) DCNL DCSP DCSP urls = tweet [ 'entities' ] [ 'urls' ] DCNL DCSP DCSP if ( not urls ) : DCNL DCSP DCSP DCSP printNicely ( light_magenta ( 'No DCSP url DCSP here DCSP @.@!' ) ) DCNL DCSP DCSP DCSP return DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for url in urls : DCNL DCSP DCSP DCSP DCSP expanded_url = url [ 'expanded_url' ] DCNL DCSP DCSP DCSP DCSP webbrowser . open ( expanded_url ) DCNL DCSP except : DCNL DCSP DCSP debug_option ( ) DCNL DCSP DCSP printNicely ( red ( "Sorry DCSP I DCSP can't DCSP open DCSP url DCSP in DCSP this DCSP tweet." ) )
DCSP res = [ ] DCNL DCSP saved_count = len ( l ) DCNL DCSP for count in counts : DCNL DCSP DCSP if ( not l ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP if ( count == ( - 1 ) ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP if ( count == 0 ) : DCNL DCSP DCSP DCSP while l : DCNL DCSP DCSP DCSP DCSP res . append ( l [ : saved_count ] ) DCNL DCSP DCSP DCSP DCSP l = l [ saved_count : ] DCNL DCSP DCSP DCSP break DCNL DCSP DCSP res . append ( l [ : count ] ) DCNL DCSP DCSP l = l [ count : ] DCNL DCSP DCSP saved_count = count DCNL DCSP if l : DCNL DCSP DCSP res . append ( l ) DCNL DCSP return res
DCSP return str ( value )
DCSP with open ( fname ) as f : DCNL DCSP DCSP data = json . load ( f ) DCNL DCSP return data
DCSP checkpointDir = _getModelCheckpointDir ( experimentDir , checkpointLabel ) DCNL DCSP if newSerialization : DCNL DCSP DCSP model . writeToCheckpoint ( checkpointDir ) DCNL DCSP else : DCNL DCSP DCSP model . save ( saveModelDir = checkpointDir )
DCSP loop_variable = LoopVariable ( ) DCNL DCSP node . accept_visitor ( loop_variable ) DCNL DCSP if loop_variable . detected : DCNL DCSP DCSP node . nodes [ ( - 1 ) ] . has_loop_context = True DCNL DCSP DCSP match = _FOR_LOOP . match ( node . text ) DCNL DCSP DCSP if match : DCNL DCSP DCSP DCSP printer . writelines ( ( 'loop DCSP = DCSP __M_loop._enter(%s)' % match . group ( 2 ) ) , 'try:' ) DCNL DCSP DCSP DCSP text = ( 'for DCSP %s DCSP in DCSP loop:' % match . group ( 1 ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise SyntaxError ( ( "Couldn't DCSP apply DCSP loop DCSP context: DCSP %s" % node . text ) ) DCNL DCSP else : DCNL DCSP DCSP text = node . text DCNL DCSP return text
DCSP return tail ( 1 , seq ) [ 0 ]
DCSP a = rs . randn ( 30 ) DCNL DCSP b = ( a + ( rs . rand ( 30 ) * 8 ) ) DCNL DCSP c = rs . randn ( 30 ) DCNL DCSP d = [ a , b , c ] DCNL DCSP p_mat_b = algo . randomize_corrmat ( d , 'both' , False , random_seed = 0 ) DCNL DCSP p_mat_u = algo . randomize_corrmat ( d , 'upper' , False , random_seed = 0 ) DCNL DCSP p_mat_l = algo . randomize_corrmat ( d , 'lower' , False , random_seed = 0 ) DCNL DCSP assert_equal ( p_mat_b [ ( 0 , 1 ) ] , ( p_mat_u [ ( 0 , 1 ) ] * 2 ) ) DCNL DCSP assert_equal ( p_mat_l [ ( 0 , 1 ) ] , ( 1 - p_mat_u [ ( 0 , 1 ) ] ) )
DCSP for i in xrange ( len ( seq ) ) : DCNL DCSP DCSP seq . pop ( )
DCSP body = XPath ( 'ancestor-or-self::h:body' ) ( elem ) DCNL DCSP if ( not body ) : DCNL DCSP DCSP return True DCNL DCSP body = body [ 0 ] DCNL DCSP ancestors = frozenset ( XPath ( 'ancestor::*' ) ( elem ) ) DCNL DCSP for x in body . iter ( ) : DCNL DCSP DCSP if ( x is elem ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP if ( hasattr ( getattr ( x , 'tag' , None ) , 'rpartition' ) and ( x . tag . rpartition ( '}' ) [ ( - 1 ) ] in { 'img' , 'svg' } ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP if ( isspace ( getattr ( x , 'text' , None ) ) and ( ( x in ancestors ) or isspace ( getattr ( x , 'tail' , None ) ) ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP return False DCNL DCSP return False
DCSP if ( ( append is not None ) and ( element is not None ) ) : DCNL DCSP DCSP if ( isinstance ( element , list ) or isinstance ( element , tuple ) ) : DCNL DCSP DCSP DCSP append . extend ( element ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP append . append ( element ) DCNL DCSP else : DCNL DCSP DCSP return element
DCSP return dict ( ( ( func ( key ) , value ) for ( key , value ) in six . iteritems ( dikt ) ) )
DCSP if ( not is_str ( obj ) ) : DCNL DCSP DCSP return coerce ( obj ) DCNL DCSP return obj
DCSP short2rgb_dict = dict ( CLUT ) DCNL DCSP rgb2short_dict = { } DCNL DCSP for ( k , v ) in short2rgb_dict . items ( ) : DCNL DCSP DCSP rgb2short_dict [ v ] = k DCNL DCSP return ( rgb2short_dict , short2rgb_dict )
DCSP now = time . localtime ( t ) DCNL DCSP ntime = ( now [ 0 ] , now [ 1 ] , now [ 2 ] , 0 , 0 , 0 , now [ 6 ] , now [ 7 ] , now [ 8 ] ) DCNL DCSP return ( time . mktime ( ntime ) + DAY )
DCSP if ( by == 'key' ) : DCNL DCSP DCSP pos = 0 DCNL DCSP elif ( by == 'value' ) : DCNL DCSP DCSP pos = 1 DCNL DCSP else : DCNL DCSP DCSP raise FilterArgumentError ( 'You DCSP can DCSP only DCSP sort DCSP by DCSP either DCSP "key" DCSP or DCSP "value"' ) DCNL DCSP def sort_func ( item ) : DCNL DCSP DCSP value = item [ pos ] DCNL DCSP DCSP if ( isinstance ( value , basestring ) and ( not case_sensitive ) ) : DCNL DCSP DCSP DCSP value = value . lower ( ) DCNL DCSP DCSP return value DCNL DCSP return sorted ( value . items ( ) , key = sort_func )
DCSP for name in names : DCNL DCSP DCSP suite = _load_tests ( name ) DCNL DCSP DCSP for test in iterate_tests ( suite ) : DCNL DCSP DCSP DCSP ( yield test )
DCSP assert isinstance ( chunks , tuple ) DCNL DCSP return tuple ( ( format_blocks ( c ) for c in chunks ) )
DCSP if ( args is None ) : DCNL DCSP DCSP args = sys . argv [ 1 : ] DCNL DCSP if ( len ( args ) != 2 ) : DCNL DCSP DCSP print ( ( 'USAGE: DCSP %s DCSP BEHAVE_FILE.json DCSP CUCUMBER_FILE.json' % NAME ) ) DCNL DCSP DCSP print ( 'Converts DCSP behave DCSP JSON DCSP dialect DCSP to DCSP cucumber DCSP JSON DCSP dialect.' ) DCNL DCSP DCSP return 1 DCNL DCSP behave_filename = args [ 0 ] DCNL DCSP cucumber_filename = args [ 1 ] DCNL DCSP return convert_behave_to_cucumber_json ( behave_filename , cucumber_filename )
DCSP if ( ( t is not None ) and ( coord_frame != t [ 'from' ] ) ) : DCNL DCSP DCSP raise RuntimeError ( 'transformation DCSP frame DCSP does DCSP not DCSP match DCSP the DCSP coil DCSP set' ) DCNL DCSP coils = deepcopy ( coils ) DCNL DCSP if ( t is not None ) : DCNL DCSP DCSP coord_frame = t [ 'to' ] DCNL DCSP DCSP for coil in coils : DCNL DCSP DCSP DCSP for key in ( 'ex' , 'ey' , 'ez' ) : DCNL DCSP DCSP DCSP DCSP if ( key in coil ) : DCNL DCSP DCSP DCSP DCSP DCSP coil [ key ] = apply_trans ( t [ 'trans' ] , coil [ key ] , False ) DCNL DCSP DCSP DCSP coil [ 'r0' ] = apply_trans ( t [ 'trans' ] , coil [ 'r0' ] ) DCNL DCSP DCSP DCSP coil [ 'rmag' ] = apply_trans ( t [ 'trans' ] , coil [ 'rmag' ] ) DCNL DCSP DCSP DCSP coil [ 'cosmag' ] = apply_trans ( t [ 'trans' ] , coil [ 'cosmag' ] , False ) DCNL DCSP DCSP DCSP coil [ 'coord_frame' ] = t [ 'to' ] DCNL DCSP return ( coils , coord_frame )
DCSP activateMultiplyString = getSettingString ( lines , 'multiply' , 'Activate DCSP Multiply' ) DCNL DCSP if ( ( activateMultiplyString == None ) or ( activateMultiplyString == 'False' ) ) : DCNL DCSP DCSP return '' DCNL DCSP columnsString = getSettingString ( lines , 'multiply' , 'Number DCSP of DCSP Columns' ) DCNL DCSP rowsString = getSettingString ( lines , 'multiply' , 'Number DCSP of DCSP Rows' ) DCNL DCSP if ( ( columnsString == '1' ) and ( rowsString == '1' ) ) : DCNL DCSP DCSP return '' DCNL DCSP return ( '_%scx%sr' % ( columnsString , rowsString ) )
DCSP return list ( set ( x ) )
DCSP if a : DCNL DCSP DCSP if six . PY3 : DCNL DCSP DCSP DCSP if isinstance ( a , bytes ) : DCNL DCSP DCSP DCSP DCSP a = a . decode ( u'ascii' ) DCNL DCSP DCSP DCSP if isinstance ( b , bytes ) : DCNL DCSP DCSP DCSP DCSP b = b . decode ( u'ascii' ) DCNL DCSP DCSP a = distutils . version . LooseVersion ( a ) DCNL DCSP DCSP b = distutils . version . LooseVersion ( b ) DCNL DCSP DCSP return ( a >= b ) DCNL DCSP else : DCNL DCSP DCSP return False
DCSP @ wraps ( func ) DCNL DCSP def wrapper ( * args , ** kwargs ) : DCNL DCSP DCSP start = time . time ( ) DCNL DCSP DCSP result = func ( * args , ** kwargs ) DCNL DCSP DCSP end = time . time ( ) DCNL DCSP DCSP print ( func . __name__ , ( end - start ) ) DCNL DCSP DCSP return result DCNL DCSP return wrapper
DCSP return type ( bytes_if_py2 ( name ) , ( parent , ) , { u'__module__' : module } )
DCSP np = import_module ( 'numpy' ) DCNL DCSP if isinstance ( x , ( int , float ) ) : DCNL DCSP DCSP return interval ( np . floor ( x ) ) DCNL DCSP elif isinstance ( x , interval ) : DCNL DCSP DCSP if ( x . is_valid is False ) : DCNL DCSP DCSP DCSP return interval ( ( - np . inf ) , np . inf , is_valid = False ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP start = np . floor ( x . start ) DCNL DCSP DCSP DCSP end = np . floor ( x . end ) DCNL DCSP DCSP DCSP if ( start == end ) : DCNL DCSP DCSP DCSP DCSP return interval ( start , end , is_valid = x . is_valid ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return interval ( start , end , is_valid = None ) DCNL DCSP else : DCNL DCSP DCSP return NotImplementedError
DCSP return ( ( value % num ) == 0 )
DCSP if isinstance ( key , tuple ) : DCNL DCSP DCSP if ( len ( key ) > 2 ) : DCNL DCSP DCSP DCSP raise IndexError ( 'Invalid DCSP index/slice.' ) DCNL DCSP DCSP key_elems = [ key [ 0 ] , key [ 1 ] ] DCNL DCSP else : DCNL DCSP DCSP key_elems = [ key ] DCNL DCSP for elem in key_elems : DCNL DCSP DCSP if ( not ( isinstance ( elem , ( numbers . Number , slice ) ) or np . isscalar ( elem ) ) ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP return dict ( [ ( x , i ) for ( i , x ) in enumerate ( arr ) ] )
DCSP if isinstance ( s , binary_type ) : DCNL DCSP DCSP return s DCNL DCSP elif isinstance ( s , Text ) : DCNL DCSP DCSP return s . encode ( encoding ) DCNL DCSP else : DCNL DCSP DCSP raise TypeError ( 'force_bytes DCSP expects DCSP a DCSP string DCSP type' )
DCSP loop_variable = LoopVariable ( ) DCNL DCSP node . accept_visitor ( loop_variable ) DCNL DCSP if loop_variable . detected : DCNL DCSP DCSP node . nodes [ ( - 1 ) ] . has_loop_context = True DCNL DCSP DCSP match = _FOR_LOOP . match ( node . text ) DCNL DCSP DCSP if match : DCNL DCSP DCSP DCSP printer . writelines ( ( 'loop DCSP = DCSP __M_loop._enter(%s)' % match . group ( 2 ) ) , 'try:' ) DCNL DCSP DCSP DCSP text = ( 'for DCSP %s DCSP in DCSP loop:' % match . group ( 1 ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise SyntaxError ( ( "Couldn't DCSP apply DCSP loop DCSP context: DCSP %s" % node . text ) ) DCNL DCSP else : DCNL DCSP DCSP text = node . text DCNL DCSP return text
DCSP for i in range ( 0 , len ( arr ) ) : DCNL DCSP DCSP r = randint ( 0 , i ) DCNL DCSP DCSP ( arr [ i ] , arr [ r ] ) = ( arr [ r ] , arr [ i ] )
DCSP users_count = Profile . objects . all ( ) . count ( ) DCNL DCSP random_index = randint ( 0 , ( users_count - 1 ) ) DCNL DCSP return Profile . objects . all ( ) [ random_index ]
DCSP return communicate ( sock , ( '__get_global__("%s")' % name ) )
DCSP print valueString DCNL DCSP return valueString
DCSP return ( isinstance ( s , unicode ) or isinstance ( s , str ) )
DCSP raise exception
DCSP dictionaryWithoutList = { } DCNL DCSP for key in dictionary : DCNL DCSP DCSP if ( key not in withoutList ) : DCNL DCSP DCSP DCSP dictionaryWithoutList [ key ] = dictionary [ key ] DCNL DCSP return dictionaryWithoutList
DCSP if ( not isinstance ( obj , obj_type ) ) : DCNL DCSP DCSP raise TypeError ( ( '%s DCSP must DCSP be DCSP a DCSP %s, DCSP got DCSP %s' % ( obj_name , obj_type , obj . __class__ . __name__ ) ) ) DCNL DCSP return obj
DCSP np = import_module ( 'numpy' ) DCNL DCSP if ( not all ( ( isinstance ( arg , ( int , float , interval ) ) for arg in args ) ) ) : DCNL DCSP DCSP return NotImplementedError DCNL DCSP else : DCNL DCSP DCSP new_args = [ a for a in args if ( isinstance ( a , ( int , float ) ) or a . is_valid ) ] DCNL DCSP DCSP if ( len ( new_args ) == 0 ) : DCNL DCSP DCSP DCSP if all ( ( ( a . is_valid is False ) for a in args ) ) : DCNL DCSP DCSP DCSP DCSP return interval ( ( - np . inf ) , np . inf , is_valid = False ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return interval ( ( - np . inf ) , np . inf , is_valid = None ) DCNL DCSP DCSP start_array = [ ( a if isinstance ( a , ( int , float ) ) else a . start ) for a in new_args ] DCNL DCSP DCSP end_array = [ ( a if isinstance ( a , ( int , float ) ) else a . end ) for a in new_args ] DCNL DCSP DCSP return interval ( max ( start_array ) , max ( end_array ) )
DCSP while ( mpstate . status . exit != True ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if ( mpstate . status . exit != True ) : DCNL DCSP DCSP DCSP DCSP line = raw_input ( mpstate . rl . prompt ) DCNL DCSP DCSP except EOFError : DCNL DCSP DCSP DCSP mpstate . status . exit = True DCNL DCSP DCSP DCSP sys . exit ( 1 ) DCNL DCSP DCSP mpstate . input_queue . put ( line )
DCSP if isinstance ( enum , string_types ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP enum = getattr ( gl , ( 'GL_' + enum . upper ( ) ) ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP enum = _internalformats [ ( 'GL_' + enum . upper ( ) ) ] DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP raise ValueError ( ( 'Could DCSP not DCSP find DCSP int DCSP value DCSP for DCSP enum DCSP %r' % enum ) ) DCNL DCSP return enum
DCSP if ( key in dictionary ) : DCNL DCSP DCSP dictionary [ key ] . append ( value ) DCNL DCSP else : DCNL DCSP DCSP dictionary [ key ] = [ value ]
DCSP arrayty = make_array ( typ ) DCNL DCSP array = arrayty ( context , builder , value ) DCNL DCSP rectype = typ . dtype DCNL DCSP if ( not isinstance ( rectype , types . Record ) ) : DCNL DCSP DCSP raise NotImplementedError ( ( 'attribute DCSP %r DCSP of DCSP %s DCSP not DCSP defined' % ( attr , typ ) ) ) DCNL DCSP dtype = rectype . typeof ( attr ) DCNL DCSP offset = rectype . offset ( attr ) DCNL DCSP resty = typ . copy ( dtype = dtype , layout = 'A' ) DCNL DCSP raryty = make_array ( resty ) DCNL DCSP rary = raryty ( context , builder ) DCNL DCSP constoffset = context . get_constant ( types . intp , offset ) DCNL DCSP llintp = context . get_value_type ( types . intp ) DCNL DCSP newdata = builder . add ( builder . ptrtoint ( array . data , llintp ) , constoffset ) DCNL DCSP newdataptr = builder . inttoptr ( newdata , rary . data . type ) DCNL DCSP datasize = context . get_abi_sizeof ( context . get_data_type ( dtype ) ) DCNL DCSP populate_array ( rary , data = newdataptr , shape = array . shape , strides = array . strides , itemsize = context . get_constant ( types . intp , datasize ) , meminfo = array . meminfo , parent = array . parent ) DCNL DCSP res = rary . _getvalue ( ) DCNL DCSP return impl_ret_borrowed ( context , builder , resty , res )
DCSP return '.' . join ( [ str ( x ) for x in obj ] )
DCSP pass
DCSP floatValue = getFloatFromCharacterSplitLine ( character , splitLine ) DCNL DCSP if ( floatValue == None ) : DCNL DCSP DCSP return None DCNL DCSP floatValue += offset DCNL DCSP integerValue = int ( round ( float ( ( floatValue / step ) ) ) ) DCNL DCSP return ( character + str ( integerValue ) )
DCSP mox = Mox ( ) DCNL DCSP old_os = io . os DCNL DCSP io . os = mox . CreateMockAnything ( ) DCNL DCSP class MyFs ( io . FileSystem , ) : DCNL DCSP DCSP stack = [ ] DCNL DCSP mox . ReplayAll ( ) DCNL DCSP try : DCNL DCSP DCSP assert ( len ( MyFs . stack ) is 0 ) DCNL DCSP DCSP MyFs . popd ( ) DCNL DCSP DCSP assert ( len ( MyFs . stack ) is 0 ) DCNL DCSP DCSP assert_equals ( MyFs . stack , [ ] ) DCNL DCSP DCSP mox . VerifyAll ( ) DCNL DCSP finally : DCNL DCSP DCSP io . os = old_os
DCSP return json . dumps ( a , cls = AnsibleJSONEncoder , * args , ** kw )
DCSP r = '' . join ( reversed ( s ) ) DCNL DCSP return r
DCSP def starts_with ( value ) : DCNL DCSP DCSP validate ( text , value ) DCNL DCSP DCSP if ( not value . startswith ( string ) ) : DCNL DCSP DCSP DCSP raise ValueError ( "'{0}' DCSP does DCSP not DCSP start DCSP with DCSP '{1}'" . format ( value , string ) ) DCNL DCSP DCSP return True DCNL DCSP return starts_with
DCSP return trimr ( data , limits = ( proportiontocut , proportiontocut ) , inclusive = inclusive , axis = axis )
DCSP args = ( ( sys . executable , ) + args ) DCNL DCSP return ( subprocess . call ( args ) == 0 )
DCSP return max ( 0 , ( 1 + int ( math . ceil ( ( extraDecimalPlaces - math . log10 ( value ) ) ) ) ) )